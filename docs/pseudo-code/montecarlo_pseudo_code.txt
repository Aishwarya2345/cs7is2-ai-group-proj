def montecarlo_tree_search(self, board, max_iterations, currentNode, timeout = 100):
        rootnode = Node(piece=board.PREV_PLAYER, board=board)

        if currentNode is not None:
            rootnode = currentNode

        start = time.perf_counter()
        for i in range(max_iterations):
            node = rootnode
            current_board_state = board.copy_board()

            # selection
            while node.available_moves == [] and node.children != []:
                node = node.selection()
                current_board_state.drop_piece(node.move, current_board_state.CURR_PLAYER)

            # expand
            if node.available_moves != []:
                col = random.choice(node.available_moves)
                current_board_state.drop_piece(col, current_board_state.CURR_PLAYER)
                node = node.expand(col, current_board_state)

            # rollout
            while current_board_state.get_valid_locations():
                col = random.choice(current_board_state.get_valid_locations())
                current_board_state.drop_piece(col, current_board_state.CURR_PLAYER)
                if current_board_state.winning_move(current_board_state.PREV_PLAYER):
                    break

            # backpropagate
            while node is not None:
                node.update(current_board_state.search_result(node.piece))
                node = node.parent

            duration = time.perf_counter() - start
            if duration > timeout:
                break

        win_ratio = lambda node: node.wins/node.visits
        sorted_children = sorted(rootnode.children, key = win_ratio)[::-1]

        return rootnode, sorted_children[0].move